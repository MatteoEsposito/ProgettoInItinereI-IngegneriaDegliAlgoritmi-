\chapter{Abstract}
\section{Premessa}
L'algoritmo presentato vorrebbe tentare di risolvere il problema N.2 il quale chiedeva:\\ 
\begin{center}
	\emph{"Siano   dati   due   alberi   AVL   A   e   B   tali   che   le   chiavi   di   uno   siano   tutte strettamente   minori   delle   chiavi   dell'altro.   Progettare   e   implementare   un algoritmo   che   restituisca   un   nuovo   albero   AVL   ottenuto   come concatenazione   di   A   e   B."}\\
\end{center}
L'approccio risolutivo consta dell'utilizzo di operazioni pre-esistenti, forniteci attraverso le classi e gli snipset presenti sulla pagina di GitHub del Corso, con una classe "extendedAVL" che riporta alcune funzioni il cui scopo \'e estendere ulteriormente la classe AVLDict. Il tempo di esecuzione totale nel caso peggiore risulta essere $O(log(n))$ in quanto ogni singola operazione svolta nel caso peggiore risulta essere eseguita per un tempo pari all'$O(log(n))$.
\\ \\
Il codice \'e cos\'i strutturato:
\begin{easylist}[itemize]
	& main.py: contenente essenzialmente le DEMO dell'algoritmo
	& la classe "ProjUtilities":contenente le principali classi ed il core dell'algoritmo stesso ( la funzione \emph{concatenate} )
	& la succitata classe extendedAVL 
	& tutte le librerie e classi fornite precedentemente attraverso la pagina di GitHub.
\end{easylist} 

